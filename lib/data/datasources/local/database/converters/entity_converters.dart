import 'package:drift/drift.dart';

import '../../../../../domain/entities/message.dart' as domain;
import '../../../../../domain/entities/chat_room.dart' as domain;
import '../app_database.dart';

/// Converts domain Message entity to Drift MessagesCompanion for database insertion
MessagesCompanion messageToCompanion(domain.Message message, {String syncStatus = 'synced'}) {
  return MessagesCompanion(
    id: Value(message.id),
    chatRoomId: Value(message.chatRoomId),
    senderId: Value(message.senderId),
    senderNickname: Value(message.senderNickname),
    senderAvatarUrl: Value(message.senderAvatarUrl),
    content: Value(message.content),
    type: Value(_messageTypeToString(message.type)),
    fileUrl: Value(message.fileUrl),
    fileName: Value(message.fileName),
    fileSize: Value(message.fileSize),
    fileContentType: Value(message.fileContentType),
    thumbnailUrl: Value(message.thumbnailUrl),
    replyToMessageId: Value(message.replyToMessageId),
    forwardedFromMessageId: Value(message.forwardedFromMessageId),
    isDeleted: Value(message.isDeleted),
    createdAt: Value(message.createdAt.millisecondsSinceEpoch),
    updatedAt: Value(message.updatedAt?.millisecondsSinceEpoch),
    unreadCount: Value(message.unreadCount),
    syncStatus: Value(syncStatus),
  );
}

/// Converts database Message (generated by Drift) to domain Message entity
domain.Message dbMessageToEntity(
  Message row,
  List<domain.MessageReaction> reactions,
) {
  return domain.Message(
    id: row.id,
    chatRoomId: row.chatRoomId,
    senderId: row.senderId,
    senderNickname: row.senderNickname,
    senderAvatarUrl: row.senderAvatarUrl,
    content: row.content,
    type: _parseMessageType(row.type),
    fileUrl: row.fileUrl,
    fileName: row.fileName,
    fileSize: row.fileSize,
    fileContentType: row.fileContentType,
    thumbnailUrl: row.thumbnailUrl,
    replyToMessageId: row.replyToMessageId,
    forwardedFromMessageId: row.forwardedFromMessageId,
    isDeleted: row.isDeleted,
    createdAt: DateTime.fromMillisecondsSinceEpoch(row.createdAt),
    updatedAt: row.updatedAt != null
        ? DateTime.fromMillisecondsSinceEpoch(row.updatedAt!)
        : null,
    reactions: reactions,
    unreadCount: row.unreadCount,
  );
}

/// Converts domain ChatRoom entity to Drift ChatRoomsCompanion for database insertion
ChatRoomsCompanion chatRoomToCompanion(domain.ChatRoom chatRoom) {
  return ChatRoomsCompanion(
    id: Value(chatRoom.id),
    name: Value(chatRoom.name),
    type: Value(_chatRoomTypeToString(chatRoom.type)),
    createdAt: Value(chatRoom.createdAt.millisecondsSinceEpoch),
    lastMessage: Value(chatRoom.lastMessage),
    lastMessageType: Value(chatRoom.lastMessageType),
    lastMessageAt: Value(chatRoom.lastMessageAt?.millisecondsSinceEpoch),
    unreadCount: Value(chatRoom.unreadCount),
    otherUserId: Value(chatRoom.otherUserId),
    otherUserNickname: Value(chatRoom.otherUserNickname),
    otherUserAvatarUrl: Value(chatRoom.otherUserAvatarUrl),
    isOtherUserLeft: Value(chatRoom.isOtherUserLeft),
    isOtherUserOnline: Value(chatRoom.isOtherUserOnline),
    otherUserLastActiveAt: Value(chatRoom.otherUserLastActiveAt?.millisecondsSinceEpoch),
  );
}

/// Converts database ChatRoom (generated by Drift) to domain ChatRoom entity
domain.ChatRoom dbChatRoomToEntity(ChatRoom row) {
  return domain.ChatRoom(
    id: row.id,
    name: row.name,
    type: _parseChatRoomType(row.type),
    createdAt: DateTime.fromMillisecondsSinceEpoch(row.createdAt),
    lastMessage: row.lastMessage,
    lastMessageType: row.lastMessageType,
    lastMessageAt: row.lastMessageAt != null
        ? DateTime.fromMillisecondsSinceEpoch(row.lastMessageAt!)
        : null,
    unreadCount: row.unreadCount,
    otherUserId: row.otherUserId,
    otherUserNickname: row.otherUserNickname,
    otherUserAvatarUrl: row.otherUserAvatarUrl,
    isOtherUserLeft: row.isOtherUserLeft,
    isOtherUserOnline: row.isOtherUserOnline,
    otherUserLastActiveAt: row.otherUserLastActiveAt != null
        ? DateTime.fromMillisecondsSinceEpoch(row.otherUserLastActiveAt!)
        : null,
  );
}

/// Converts domain MessageReaction to Drift MessageReactionsCompanion
MessageReactionsCompanion reactionToCompanion(domain.MessageReaction reaction) {
  return MessageReactionsCompanion(
    id: Value(reaction.id),
    messageId: Value(reaction.messageId),
    userId: Value(reaction.userId),
    userNickname: Value(reaction.userNickname),
    emoji: Value(reaction.emoji),
  );
}

/// Converts database MessageReaction (generated by Drift) to domain MessageReaction entity
domain.MessageReaction dbReactionToEntity(MessageReaction row) {
  return domain.MessageReaction(
    id: row.id,
    messageId: row.messageId,
    userId: row.userId,
    userNickname: row.userNickname,
    emoji: row.emoji,
  );
}

// Helper functions for type conversions

String _messageTypeToString(domain.MessageType type) {
  switch (type) {
    case domain.MessageType.text:
      return 'TEXT';
    case domain.MessageType.image:
      return 'IMAGE';
    case domain.MessageType.file:
      return 'FILE';
    case domain.MessageType.system:
      return 'SYSTEM';
  }
}

domain.MessageType _parseMessageType(String value) {
  switch (value.toUpperCase()) {
    case 'IMAGE':
      return domain.MessageType.image;
    case 'FILE':
      return domain.MessageType.file;
    case 'SYSTEM':
      return domain.MessageType.system;
    default:
      return domain.MessageType.text;
  }
}

String _chatRoomTypeToString(domain.ChatRoomType type) {
  switch (type) {
    case domain.ChatRoomType.direct:
      return 'DIRECT';
    case domain.ChatRoomType.group:
      return 'GROUP';
    case domain.ChatRoomType.self:
      return 'SELF';
  }
}

domain.ChatRoomType _parseChatRoomType(String value) {
  switch (value.toUpperCase()) {
    case 'GROUP':
      return domain.ChatRoomType.group;
    case 'SELF':
      return domain.ChatRoomType.self;
    default:
      return domain.ChatRoomType.direct;
  }
}
